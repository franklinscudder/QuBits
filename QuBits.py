# -*- coding: utf-8 -*-
"""QuantumLib.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YdU_aCaJNfnALncDSFavli-L0VFYIUsN
"""

import numpy as np
import scipy.linalg as sp
import random

class register:
    """ An N-bit quantum register object, with 2^N states. """
    def __init__(self, NBits):
        self.NBits = NBits
        self.NStates = 2 ** NBits
        self.amps = np.zeros(self.NStates, dtype=np.dtype(complex))
        self.amps[0] = 1 + 0j
    
    def probabilites(self):
        """ Returns the probability associated with observing each state. """
        return np.array([abs(i)**2 for i in self.amps])
    
    def observe(self):
        """ 'Observes' the register and returns an integer representation of the observed state according to the probability amplitudes. """
        probs = self.probabilites()
        return random.choices(range(self.NStates), probs)
    
    def __str__(self):
        stri = ""
        for state, amp in enumerate(self.amps):
            stri = stri + f' {amp:.3f}'.rjust(15) + " |" + str(state).ljust(2) + "> +\r\n"
        return stri.rstrip("+\r\n")
    

class genericGate:
    """ A base class for callable quantum logic gates. """
    def __init__(self, NBits):
        self.NBits = NBits
        self.matrix = np.identity(2 ** NBits)
    
    def __call__(self, arg):
        result = register(arg.NBits)
        result.amps = np.matmul(self.matrix, arg.amps)
        return result
    
    def __str__(self):
        stri = str(self.NBits) + "-bit " + type(self).__name__ + " Gate, Matrix:\n\r"
        stri = stri + self.matrix.__str__()
        return stri

class hadamard(genericGate):
    """ Implementation of a callable hadamard gate object """
    def __init__(self, NBits):
        super(hadamard, self).__init__(NBits)
        self.matrix = sp.hadamard(2 ** NBits) * (2**(-0.5*(NBits)))

class phaseShift(genericGate):
    """ Implementation of a callable phase-shift gate object """
    def __init__(self, NBits, phi):
        super(phaseShift, self).__init__(NBits)
        self.matrix = np.array([[1,0],[0,np.exp(phi * 1j)]])
        m0 = self.matrix
        
        for i in range(NBits - 1):
            self.matrix = np.kron(self.matrix, m0)

def join(regA, regB):
    """ Joins two registers into a single larger register with regA at the MSB and regB at the LSB. """
    result = register(regA.NBits + regB.NBits)
    result.amps = np.kron(regA.amps, regB.amps)    ### Needs more testing
    return result



def pauliZ(reg):
    return phaseShift(reg, np.pi)

h = hadamard(2)
r1 = h(register(2))
r2 = h(register(2))
p = phaseShift(4,np.pi/5)

print(p(join(r1,r2)))